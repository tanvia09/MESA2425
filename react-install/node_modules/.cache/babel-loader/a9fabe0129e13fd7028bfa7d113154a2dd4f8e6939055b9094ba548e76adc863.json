{"ast":null,"code":"'use strict';\n\nconst mimicFn = require(\"mimic-fn\");\nconst mapAgeCleaner = require(\"map-age-cleaner\");\nconst decoratorInstanceMap = new WeakMap();\nconst cacheStore = new WeakMap();\n/**\r\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\r\n\r\n@param fn - Function to be memoized.\r\n\r\n@example\r\n```\r\nimport mem = require('mem');\r\n\r\nlet i = 0;\r\nconst counter = () => ++i;\r\nconst memoized = mem(counter);\r\n\r\nmemoized('foo');\r\n//=> 1\r\n\r\n// Cached as it's the same arguments\r\nmemoized('foo');\r\n//=> 1\r\n\r\n// Not cached anymore as the arguments changed\r\nmemoized('bar');\r\n//=> 2\r\n\r\nmemoized('bar');\r\n//=> 2\r\n```\r\n*/\nconst mem = (fn, {\n  cacheKey,\n  cache = new Map(),\n  maxAge\n} = {}) => {\n  if (typeof maxAge === 'number') {\n    // TODO: Drop after https://github.com/SamVerschueren/map-age-cleaner/issues/5\n    // @ts-expect-error\n    mapAgeCleaner(cache);\n  }\n  const memoized = function (...arguments_) {\n    const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n    const cacheItem = cache.get(key);\n    if (cacheItem) {\n      return cacheItem.data;\n    }\n    const result = fn.apply(this, arguments_);\n    cache.set(key, {\n      data: result,\n      maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY\n    });\n    return result;\n  };\n  mimicFn(memoized, fn, {\n    ignoreNonConfigurable: true\n  });\n  cacheStore.set(memoized, cache);\n  return memoized;\n};\n/**\r\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\r\n\r\n@example\r\n```\r\nimport mem = require('mem');\r\n\r\nclass Example {\r\n    index = 0\r\n\r\n    @mem.decorator()\r\n    counter() {\r\n        return ++this.index;\r\n    }\r\n}\r\n\r\nclass ExampleWithOptions {\r\n    index = 0\r\n\r\n    @mem.decorator({maxAge: 1000})\r\n    counter() {\r\n        return ++this.index;\r\n    }\r\n}\r\n```\r\n*/\nmem.decorator = (options = {}) => (target, propertyKey, descriptor) => {\n  const input = target[propertyKey];\n  if (typeof input !== 'function') {\n    throw new TypeError('The decorated value must be a function');\n  }\n  delete descriptor.value;\n  delete descriptor.writable;\n  descriptor.get = function () {\n    if (!decoratorInstanceMap.has(this)) {\n      const value = mem(input, options);\n      decoratorInstanceMap.set(this, value);\n      return value;\n    }\n    return decoratorInstanceMap.get(this);\n  };\n};\n/**\r\nClear all cached data of a memoized function.\r\n\r\n@param fn - Memoized function.\r\n*/\nmem.clear = fn => {\n  const cache = cacheStore.get(fn);\n  if (!cache) {\n    throw new TypeError('Can\\'t clear a function that was not memoized!');\n  }\n  if (typeof cache.clear !== 'function') {\n    throw new TypeError('The cache Map can\\'t be cleared!');\n  }\n  cache.clear();\n};\nmodule.exports = mem;","map":{"version":3,"names":["mimicFn","require","mapAgeCleaner","decoratorInstanceMap","WeakMap","cacheStore","mem","fn","cacheKey","cache","Map","maxAge","memoized","arguments_","key","cacheItem","get","data","result","apply","set","Date","now","Number","POSITIVE_INFINITY","ignoreNonConfigurable","decorator","options","target","propertyKey","descriptor","input","TypeError","value","writable","has","clear","module","exports"],"sources":["C:/Users/Anand/OneDrive/Desktop/MESA2425/node_modules/mem/dist/index.js"],"sourcesContent":["'use strict';\r\nconst mimicFn = require(\"mimic-fn\");\r\nconst mapAgeCleaner = require(\"map-age-cleaner\");\r\nconst decoratorInstanceMap = new WeakMap();\r\nconst cacheStore = new WeakMap();\r\n/**\r\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\r\n\r\n@param fn - Function to be memoized.\r\n\r\n@example\r\n```\r\nimport mem = require('mem');\r\n\r\nlet i = 0;\r\nconst counter = () => ++i;\r\nconst memoized = mem(counter);\r\n\r\nmemoized('foo');\r\n//=> 1\r\n\r\n// Cached as it's the same arguments\r\nmemoized('foo');\r\n//=> 1\r\n\r\n// Not cached anymore as the arguments changed\r\nmemoized('bar');\r\n//=> 2\r\n\r\nmemoized('bar');\r\n//=> 2\r\n```\r\n*/\r\nconst mem = (fn, { cacheKey, cache = new Map(), maxAge } = {}) => {\r\n    if (typeof maxAge === 'number') {\r\n        // TODO: Drop after https://github.com/SamVerschueren/map-age-cleaner/issues/5\r\n        // @ts-expect-error\r\n        mapAgeCleaner(cache);\r\n    }\r\n    const memoized = function (...arguments_) {\r\n        const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\r\n        const cacheItem = cache.get(key);\r\n        if (cacheItem) {\r\n            return cacheItem.data;\r\n        }\r\n        const result = fn.apply(this, arguments_);\r\n        cache.set(key, {\r\n            data: result,\r\n            maxAge: maxAge ? Date.now() + maxAge : Number.POSITIVE_INFINITY\r\n        });\r\n        return result;\r\n    };\r\n    mimicFn(memoized, fn, {\r\n        ignoreNonConfigurable: true\r\n    });\r\n    cacheStore.set(memoized, cache);\r\n    return memoized;\r\n};\r\n/**\r\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\r\n\r\n@example\r\n```\r\nimport mem = require('mem');\r\n\r\nclass Example {\r\n    index = 0\r\n\r\n    @mem.decorator()\r\n    counter() {\r\n        return ++this.index;\r\n    }\r\n}\r\n\r\nclass ExampleWithOptions {\r\n    index = 0\r\n\r\n    @mem.decorator({maxAge: 1000})\r\n    counter() {\r\n        return ++this.index;\r\n    }\r\n}\r\n```\r\n*/\r\nmem.decorator = (options = {}) => (target, propertyKey, descriptor) => {\r\n    const input = target[propertyKey];\r\n    if (typeof input !== 'function') {\r\n        throw new TypeError('The decorated value must be a function');\r\n    }\r\n    delete descriptor.value;\r\n    delete descriptor.writable;\r\n    descriptor.get = function () {\r\n        if (!decoratorInstanceMap.has(this)) {\r\n            const value = mem(input, options);\r\n            decoratorInstanceMap.set(this, value);\r\n            return value;\r\n        }\r\n        return decoratorInstanceMap.get(this);\r\n    };\r\n};\r\n/**\r\nClear all cached data of a memoized function.\r\n\r\n@param fn - Memoized function.\r\n*/\r\nmem.clear = (fn) => {\r\n    const cache = cacheStore.get(fn);\r\n    if (!cache) {\r\n        throw new TypeError('Can\\'t clear a function that was not memoized!');\r\n    }\r\n    if (typeof cache.clear !== 'function') {\r\n        throw new TypeError('The cache Map can\\'t be cleared!');\r\n    }\r\n    cache.clear();\r\n};\r\nmodule.exports = mem;\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}